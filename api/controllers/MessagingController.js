/**
 * MessagingController
 *
 * @description :: Server-side logic for managing Messagings
 * @help        :: See http://sailsjs.org/#!/documentation/concepts/Controllers
 */

const { SqlUtils, CommonUtils } = require('similie-api-services');

module.exports = {
  findOne: async function(req, res) {
    const message = await new Promise(resolve => {
      Utils.findOne(req, res, resolve);
    });

    if (!message) {
      return message;
    }
    const user = req.user;
    const config = await Site.thisSiteAsync(res.locals.domain);

    if (message && !message.from) {
      message.from = await User.similieUser(res.locals.domain);
    }

    const replacement = await Message.fillMessage(message.message);
    message.message = {
      ...replacement
    };
    const messageLocals = await Message.messageLocals(message.from, config);
    Messaging.placeLocals(message, messageLocals, user);
    res.send(message);
  },

  find: async function(req, res) {
    const messages = await new Promise(resolve => {
      Utils.getParser(req, res, resolve);
    });

    const user = req.user;
    const config = await Site.thisSiteAsync(res.locals.domain);

    const deliveries = [];

    if (_.isArray(messages)) {
      for (let i = 0; i < _.size(messages); i++) {
        const m = messages[i];
        if (!m.delivered) {
          m.delivered = true;
          deliveries.push(Messaging.getId(m));
        }
        if (m && !m.from) {
          m.from = await User.similieUser(res.locals.domain);
        }
        const replacement = await Message.fillMessage(m.message);
        m.message = {
          ...replacement
        };
        const messageLocals = await Message.messageLocals(m.from, config);
        Messaging.placeLocals(m, messageLocals, user);
      }
    } else {
      if (!messages.delivered) {
        messages.delivered = true;
        deliveries.push(Messaging.getId(messages));
      }
      if (messages && !messages.from) {
        messages.from = await User.similieUser(res.locals.domain);
      }

      const replacement = await Message.fillMessage(messages.message);
      messages.message = {
        ...replacement
      };
      const messageLocals = await Message.messageLocals(messages.from, config);
      Messaging.placeLocals(messages, messageLocals, user);
    }
    Messaging.setDelivery(deliveries);
    res.send(messages);
  },

  read: function(req, res) {
    const _params = req.params.all();
    const escape = SqlUtils.escapeUtil();
    let params = _params;
    if (_.isString(_params)) {
      try {
        const values = JSON.parse(_params);
        params = {
          ...values
        };
      } catch (e) {
        return res.badRequest('errors.UNABLE_TO_PARSE_REQUEST');
      }
    }

    params.ids = CommonUtils.coerceToArray(params.ids);
    params.ids = Utils.stripUndefinedId(params.ids);
    if (!params.ids || !params.ids.length) {
      return res.badRequest();
    }

    const to = params.to || (params.where || {}).to || req.user.id;
    const read = params.read || false;

    /** @summary Inline function to create a comma separated list of Ids */
    const inStatement = idList => {
      const result = [];
      _.each(idList, id => {
        result.push(id);
      });
      return result.join(',');
    };

    const query = `
    SELECT DISTINCT(oMessage.id), msg.read 
    FROM messaging msg JOIN (
      SELECT * from messaging 
      WHERE "id" IN (${inStatement(params.ids)})
      AND "to" = %s
    ) AS oMessage 
    ON msg.original_message = oMessage.original_message 
    WHERE msg.read = %s AND msg."to" = %s AND msg."from" <> %s
    `;

    Messaging.query(escape(query, to, read, to, to), (err, results) => {
      if (err) {
        return res.serverError(err);
      }

      const rows = results.rows;
      const send = {};

      _.each(rows, row => {
        send[row.id] = row.read;
      });

      res.send(send);
    });
  },

  accountant: function(req, res) {
    /*
    @todo:: accout for the messaging values that are for each query. We send 0 for now
     because the values come from unread, but this needs to change
    */
    const count = { total: 0 };
    return res.send(count);
  },

  conversations: async function(req, res) {
    if (req.method === 'POST') {
      const counts = await Messaging.getConverstationCount(req);
      return res.send(counts);
    }
    const ids = await Messaging.generateMessageIds(req);

    if (!_.size(ids)) {
      return res.send(ids);
    }
    const messages = await Message.find()
      .where({ id: ids })
      .sort(Utils.sort(req))
      .populateAll();
    await Message.seakAutoGeneratedMessage(messages, res.locals.domain);
    const reads = await Messaging.getReadElements(ids, req.user);
    Messaging.applyReads(messages, reads);
    return res.send(messages);
  }
};
